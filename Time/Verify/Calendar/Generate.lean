import Time
import Time.Data.List.Basic

/-!
## Generate theorems

Generate theorems about `Time.monthLastDayAsDayOfYear'`.

Maybe there is another way to to this.

-/

namespace Verify.Generate

open Time

def gen_monthLastDayAsDayOfYear'_month_eq (a_1 p_2_1 p_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_monthLastDayAsDayOfYear'_month_eq`. -/" ++ "\n"
  ++ s!"theorem monthLastDayAsDayOfYear'_month_{a_1}_eq (dt : Date) (isleap : Bool)" ++ "\n"
  ++ "    (a : { x // x ∈ monthLastDayAsDayOfYear' isleap ∧ x.fst = dt.Month.val })" ++ "\n"
  ++ s!"  (h1 : (if isleap then {p_2_1} else {p_2_1'}) < a.val.2.1 )" ++ "\n"
  ++ s!"  (h2 : a.val.2.1 ≤ (if isleap then {n_2_1} else {n_2_1'}))" ++ "\n"
  ++ s!"    : {a_1} = a.val.1 := by" ++ "\n"
  ++ "  by_contra" ++ "\n"
  ++ s!"  have : ¬((if isleap then {p_2_1} else {p_2_1'}) < a.val.snd.fst" ++ "\n"
  ++ s!"           ∧ a.val.snd.fst ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"    have : ∀ a ∈ monthLastDayAsDayOfYear' isleap, ¬{a_1} = a.1" ++ "\n"
  ++ s!"        → ¬((if isleap then {p_2_1} else {p_2_1'}) < a.2.1 ∧ a.2.1 ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"      cases isleap <;> simp [monthLastDayAsDayOfYear']" ++ "\n"
  ++ s!"    exact this a a.property.left (by omega)" ++ "\n"
  ++ s!"  have : (if isleap then {p_2_1} else {p_2_1'}) < a.val.2.1" ++ "\n"
  ++ s!"         ∧ a.val.2.1 ≤ (if isleap then {n_2_1} else {n_2_1'}) := And.intro h1 h2" ++ "\n"
  ++ s!"  contradiction" ++ "\n"

def gen_month_if_eq (a_1 plen : Nat) : String :=
  "/-- Generated by `gen_month_if_eq`. -/" ++ "\n"
  ++ s!"theorem month_{a_1}_if_eq (isLeap : Bool) (h: ml ∈ monthLengths isLeap)" ++ "\n"
  ++ s!"    : ml.1 = {a_1} → ml.2 = {plen} := by" ++ "\n"
  ++ s!"  intro" ++ "\n"
  ++ s!"  rename_i h" ++ "\n"
  ++ s!"  have : ∀ ml, ml ∈ monthLengths isLeap ∧ ml.1 =  {a_1} → ml.2 = {plen} := by" ++ "\n"
  ++ s!"    simp [monthLengths]" ++ "\n"
  ++ s!"  simp [this ml (And.intro (by simp_all) h)]" ++ "\n"

def gen_monthLastDayAsDayOfYear'_month_eq' (a_1 p_2_1 p_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_monthLastDayAsDayOfYear'_month_eq'`. -/" ++ "\n"
  ++ s!"theorem monthLastDayAsDayOfYear'_month_{a_1}_eq' (dt : Date) (isleap : Bool)" ++ "\n"
  ++ "    (a : { x // x ∈ monthLastDayAsDayOfYear' isleap ∧ x.fst = dt.Month.val })" ++ "\n"
  ++ s!"  (h1 : (if isleap then {p_2_1-1} else {p_2_1'-1}) < a.val.2.1 )" ++ "\n"
  ++ s!"  (h2 : a.val.2.1 ≤ (if isleap then {n_2_1} else {n_2_1'}))" ++ "\n"
  ++ s!"    : {a_1-1} = a.val.1 ∨ {a_1} = a.val.1 := by" ++ "\n"
  ++ "  by_contra" ++ "\n"
  ++ s!"  have : ¬((if isleap then {p_2_1-1} else {p_2_1'-1}) < a.val.snd.fst" ++ "\n"
  ++ s!"           ∧ a.val.snd.fst ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"    have : ∀ a ∈ monthLastDayAsDayOfYear' isleap, ¬({a_1-1} = a.1 ∨ {a_1} = a.1)" ++ "\n"
  ++ s!"        → ¬((if isleap then {p_2_1-1} else {p_2_1'-1}) < a.2.1 ∧ a.2.1 ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"      cases isleap <;> simp [monthLastDayAsDayOfYear']" ++ "\n"
  ++ s!"    exact this a a.property.left (by omega)" ++ "\n"
  ++ s!"  have : (if isleap then {p_2_1-1} else {p_2_1'-1}) < a.val.2.1" ++ "\n"
  ++ s!"         ∧ a.val.2.1 ≤ (if isleap then {n_2_1} else {n_2_1'}) := And.intro h1 h2" ++ "\n"
  ++ s!"  contradiction" ++ "\n"

def gen_monthLastDayAsDayOfYear'_day_of_month_eq (a_1 a_2_1 a_2_1' : Nat) : String :=
  "/-- Generated by `gen_monthLastDayAsDayOfYear'_day_of_month_eq`. -/" ++ "\n"
  ++ s!"theorem monthLastDayAsDayOfYear'_day_of_month_{a_1}_eq (dt : Date) (isleap : Bool)" ++ "\n"
  ++ s!"  (a : \{ x // x ∈ monthLastDayAsDayOfYear' isleap ∧ x.fst = dt.Month.val }) (h : a.val.1 = {a_1})" ++ "\n"
  ++ s!"    : (if isleap then {a_2_1} else {a_2_1'}) = a.val.2.1 := by" ++ "\n"
  ++ "  by_contra" ++ "\n"
  ++ s!"  have : ¬a.val.1 = {a_1} := by" ++ "\n"
  ++ s!"    have : ∀ a ∈ monthLastDayAsDayOfYear' isleap, ¬(if isleap then {a_2_1} else {a_2_1'}) = a.2.1 → ¬a.1 = {a_1} := by" ++ "\n"
  ++ "      cases isleap <;> simp [monthLastDayAsDayOfYear']" ++ "\n"
  ++ "    exact this a a.property.left (by omega)" ++ "\n"
  ++ "  contradiction" ++ "\n" ++ "\n"

def genMonthTheorems : IO Unit :=
  List.range' 3 8
  |> List.forM $ (fun i => do
    let m := (monthLastDayAsDayOfYear' true).get! i
    let m' := (monthLastDayAsDayOfYear' false).get! i
    let p1 := (monthLastDayAsDayOfYear' true).get! (i-1)
    let p2 := (monthLastDayAsDayOfYear' false).get! (i-1)
    let pLen := p2.2.2-p2.2.1+1
    let n1 := (monthLastDayAsDayOfYear' true).get! (i+1)
    let n2 := (monthLastDayAsDayOfYear' false).get! (i+1)
    IO.println (gen_monthLastDayAsDayOfYear'_month_eq m.1 p1.2.1 p2.2.1 (n1.2.1-2) (n2.2.1-2))
    IO.println (gen_monthLastDayAsDayOfYear'_day_of_month_eq m.1 m.2.1 m'.2.1)
    if pLen < 31 then
      IO.println (gen_monthLastDayAsDayOfYear'_month_eq' m.1 p1.2.1 p2.2.1 (n1.2.1-2) (n2.2.1-2))
      IO.println (gen_month_if_eq (m.1-1) pLen)
    )

--#eval genMonthTheorems

def gen_dy'_month_eq (a_1 p_2_1 p_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_dy'_month_eq`. -/" ++ "\n"
  ++ s!"theorem dy'_month_{a_1}_eq (dt : Date) (isleap : Bool)" ++ "\n"
  ++ s!"  (h : dt.Day.val < 31)" ++ "\n"
  ++ s!"  (h1 : (if isleap then {p_2_1} else {p_2_1'}) < dy' isleap dt.Month dt.Day + 1)" ++ "\n"
  ++ s!"  (h2 : dy' isleap dt.Month dt.Day ≤ if isleap then {n_2_1} else {n_2_1'})" ++ "\n"
  ++ s!"    : {a_1} = dt.Month.val := by" ++ "\n"
  ++ s!"  simp [dy'] at h1" ++ "\n"
  ++ s!"  simp [dy'] at h2" ++ "\n"
  ++ s!"  let a := memOfMonth isleap dt.Month" ++ "\n"
  ++ s!"  have : a = memOfMonth isleap dt.Month := by simp" ++ "\n"
  ++ s!"  rw [← this] at h1" ++ "\n"
  ++ s!"  rw [← this] at h2" ++ "\n"
  ++ s!"  have := dt.Day.property" ++ "\n"
  ++ s!"  have := a.property" ++ "\n"
  ++ s!"  cases isleap <;> simp [] at h1 <;> simp [] at h2" ++ "\n"
  ++ s!"  · simp_all [monthLastDayAsDayOfYear'_month_{a_1}_eq dt false a  (by simp; omega) (by simp; omega)]" ++ "\n"
  ++ s!"  · simp_all [monthLastDayAsDayOfYear'_month_{a_1}_eq dt true a  (by simp; omega) (by simp; omega)]" ++ "\n"

def gen_dy'_month_day_eq (a_1 p_2_1 p_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_dy'_month_day_eq`. -/" ++ "\n"
  ++ s!"theorem dy'_month_{a_1}_day_eq (dt : Date) (isleap : Bool)" ++ "\n"
  ++ s!"  (h : dt.Day.val < 31)" ++ "\n"
  ++ s!"  (h1 : (if isleap then {p_2_1} else {p_2_1'}) < dy' isleap dt.Month dt.Day + 1)" ++ "\n"
  ++ s!"  (h2 : dy' isleap dt.Month dt.Day ≤ if isleap then {n_2_1} else {n_2_1'})" ++ "\n"
  ++ s!"    : dt.Day.val + 1 = dy' isleap dt.Month dt.Day - (if isleap then {p_2_1-1} else {p_2_1'-1}) := by" ++ "\n"
  ++ s!"  simp [dy']" ++ "\n"
  ++ s!"  let a := memOfMonth isleap dt.Month" ++ "\n"
  ++ s!"  have : a = memOfMonth isleap dt.Month := by simp" ++ "\n"
  ++ s!"  rw [← this]" ++ "\n"
  ++ s!"  have := dy'_month_{a_1}_eq dt isleap h h1 h2" ++ "\n"
  ++ s!"  have := monthLastDayAsDayOfYear'_day_of_month_{a_1}_eq dt isleap a (by omega)" ++ "\n"
  ++ s!"  cases isleap <;> simp_all <;> omega" ++ "\n"

def gen_dy'_month_if_lt (a_1 plen : Nat) : String :=
  "/-- Generated by `gen_dy'_month_if_lt`. -/" ++ "\n"
  ++ s!"theorem month_{a_1}_if_lt \{dt : Date} (isLeap : Bool)" ++ "\n"
  ++ "  {ml : { m // monthLengthsOfDate m dt }}" ++ "\n"
  ++ "  (hml : ml = monthLengths_of_date dt) (h : dt.Day.val < ml.val.snd)" ++ "\n"
  ++ s!"  (hl : isLeapYear dt.Year = isLeap)" ++ "\n"
  ++ s!"    : dt.Month.val = {a_1} → dt.Day.val < {plen} := by" ++ "\n"
  ++ s!"  have hp := ml.property" ++ "\n"
  ++ s!"  simp [monthLengthsOfDate] at hp" ++ "\n"
  ++ s!"  intro" ++ "\n"
  ++ s!"  rename_i h" ++ "\n"
  ++ s!"  rw [← hp.right.left] at h" ++ "\n"
  ++ s!"  have hm := @month_{a_1}_if_eq ml.val isLeap (by have := ml.property.left; rwa [hl] at this)" ++ "\n"
  ++ s!"  simp [monthLengths, h] at hm" ++ "\n"
  ++ s!"  have := ml.property" ++ "\n"
  ++ s!"  simp_all" ++ "\n"

def gen_dy'_month_eq' (a_1 a_2_1 a_2_1' p_2_1 p_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_dy'_month_eq'`. -/" ++ "\n"
  ++ s!"theorem dy'_month_{a_1}_eq (dt : Date) (isleap : Bool)" ++ "\n"
  ++ s!"  (h : dt.Day.val < 31)" ++ "\n"
  ++ s!"  (h' : dt.Month.val = {a_1-1} → dt.Day.val < 30)" ++ "\n"
  ++ s!"  (h1 : (if isleap then {a_2_1} else {a_2_1'}) < dy' isleap dt.Month dt.Day + 1)" ++ "\n"
  ++ s!"  (h2 : dy' isleap dt.Month dt.Day ≤ if isleap then {n_2_1} else {n_2_1'})" ++ "\n"
  ++ s!"    : {a_1} = dt.Month.val := by" ++ "\n"
  ++ s!"  simp [dy'] at h1" ++ "\n"
  ++ s!"  simp [dy'] at h2" ++ "\n"
  ++ s!"  let a := memOfMonth isleap dt.Month" ++ "\n"
  ++ s!"  have : a = memOfMonth isleap dt.Month := by simp" ++ "\n"
  ++ s!"  rw [← this] at h1" ++ "\n"
  ++ s!"  rw [← this] at h2" ++ "\n"
  ++ s!"  have := dt.Day.property" ++ "\n"
  ++ s!"  have := a.property" ++ "\n"
  ++ s!"  have hmem : a.val.fst = dt.Month.val := a.property.right" ++ "\n"
  ++ s!"  rw [← hmem] at h'" ++ "\n"
  ++ s!"  cases isleap <;> simp [] at h1 <;> simp [] at h2" ++ "\n"
  ++ s!"  · have h' : a.val.fst = {a_1-1} → {p_2_1'} < a.val.snd.fst := by omega" ++ "\n"
  ++ s!"    have := monthLastDayAsDayOfYear'_month_{a_1}_eq' dt false a  (by simp; omega) (by simp; omega)" ++ "\n"
  ++ s!"    cases this" ++ "\n"
  ++ s!"    · rename_i h''" ++ "\n"
  ++ s!"      have := monthLastDayAsDayOfYear'_month_{a_1}_eq dt false a (h' h''.symm) (by simp; omega)" ++ "\n"
  ++ s!"      simp_all only [Bool.false_eq_true]" ++ "\n"
  ++ s!"    · simp_all" ++ "\n"
  ++ s!"  · have h' : a.val.fst = {a_1-1} → {p_2_1} < a.val.snd.fst := by omega" ++ "\n"
  ++ s!"    have := monthLastDayAsDayOfYear'_month_{a_1}_eq' dt true a  (by simp; omega) (by simp; omega)" ++ "\n"
  ++ s!"    cases this" ++ "\n"
  ++ s!"    · rename_i h''" ++ "\n"
  ++ s!"      have := monthLastDayAsDayOfYear'_month_{a_1}_eq dt true a (h' h''.symm) (by simp; omega)" ++ "\n"
  ++ s!"      simp_all only [Bool.false_eq_true]" ++ "\n"
  ++ s!"    · simp_all" ++ "\n"

def gen_dy'_month_day_eq' (a_1 p_2_1 p_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_dy'_month_day_eq'`. -/" ++ "\n"
  ++ s!"theorem dy'_month_{a_1}_day_eq (dt : Date) (isleap : Bool)" ++ "\n"
  ++ s!"  (h : dt.Day.val < 31)" ++ "\n"
  ++ s!"  (h' : dt.Month.val = {a_1-1} → dt.Day.val < 30)" ++ "\n"
  ++ s!"  (h1 : (if isleap then {p_2_1} else {p_2_1'}) < dy' isleap dt.Month dt.Day + 1)" ++ "\n"
  ++ s!"  (h2 : dy' isleap dt.Month dt.Day ≤ if isleap then {n_2_1} else {n_2_1'})" ++ "\n"
  ++ s!"    : dt.Day.val + 1 = dy' isleap dt.Month dt.Day - (if isleap then {p_2_1-1} else {p_2_1'-1}) := by" ++ "\n"
  ++ s!"  simp [dy']" ++ "\n"
  ++ s!"  let a := memOfMonth isleap dt.Month" ++ "\n"
  ++ s!"  have : a = memOfMonth isleap dt.Month := by simp" ++ "\n"
  ++ s!"  rw [← this]" ++ "\n"
  ++ s!"  have := dy'_month_{a_1}_eq dt isleap h h' h1 h2" ++ "\n"
  ++ s!"  have := monthLastDayAsDayOfYear'_day_of_month_{a_1}_eq dt isleap a (by omega)" ++ "\n"
  ++ s!"  cases isleap <;> simp_all <;> omega" ++ "\n"

def genDy'Theorems : IO Unit :=
  List.range' 3 8
  |> List.forM $ (fun i => do
    let m := (monthLastDayAsDayOfYear' true).get! i
    let m' := (monthLastDayAsDayOfYear' false).get! i
    let p1 := (monthLastDayAsDayOfYear' true).get! (i-1)
    let p2 := (monthLastDayAsDayOfYear' false).get! (i-1)
    let pLen := p2.2.2-p2.2.1+1
    let n1 := (monthLastDayAsDayOfYear' true).get! (i+1)
    let n2 := (monthLastDayAsDayOfYear' false).get! (i+1)
    if pLen = 31 then
      IO.println (gen_dy'_month_eq m.1 (m.2.1-1) (m'.2.1-1) (n1.2.1-2) (n2.2.1-2))
      IO.println (gen_dy'_month_day_eq m.1 (m.2.1-1) (m'.2.1-1) (n1.2.1-2) (n2.2.1-2))
    else
      IO.println (gen_dy'_month_if_lt (m.1-1) pLen)
      IO.println (gen_dy'_month_eq' m.1 (m.2.1-1) (m'.2.1-1) (p1.2.1) (p2.2.1) (n1.2.1-2) (n2.2.1-2))
      IO.println (gen_dy'_month_day_eq' m.1 (m.2.1-1) (m'.2.1-1) (n1.2.1-2) (n2.2.1-2))
    )

--#eval genDy'Theorems

def gen_findValidMonthDay_month_eq (a_1 : Nat) : String :=
  "/-- Generated by `gen_findValidMonthDay_month_eq`. -/" ++ "\n"
  ++ s!"theorem findValidMonthDay_{a_1}_month_eq \{dt : Date} (isLeap : Bool) (yd : Time.Icc 1 366)" ++ "\n"
  ++ "  {ml : { m // monthLengthsOfDate m dt }}" ++ "\n"
  ++ "  (hml : ml = monthLengths_of_date dt) (h : dt.Day.val < ml.val.snd)" ++ "\n"
  ++ "  (heq : Time.dy' isLeap dt.Month dt.Day = yd.val) (hle : yd.val + 1 ≤ if isLeap then 366 else 365)" ++ "\n"
  ++ "  (hl : isLeapYear dt.Year = isLeap)" ++ "\n"
  ++ s!"  (hne : ¬yd.val + 1 ≤ (monthLastDayAsDayOfYear isLeap)[{a_1-2}].snd)" ++ "\n"
  ++ s!"  (hyd : yd.val+1 ≤ ((monthLastDayAsDayOfYear isLeap).get ⟨{a_1-1}, by simp⟩).2)" ++ "\n"
  ++ s!"    : (findValidMonthDay_{a_1} dt.Year isLeap ⟨yd + 1, incr_of_yd_in yd isLeap hle⟩ hl hne hyd).Month" ++ "\n"
  ++ "        = dt.Month" ++ "\n"
  ++ "      ∧ ⟨dt.Day.val + 1, incr_of_day_in_intervall dt ml h⟩" ++ "\n"
  ++ s!"        = (findValidMonthDay_{a_1} dt.Year isLeap ⟨yd.val + 1, incr_of_yd_in yd isLeap hle⟩ hl hne hyd).Day" ++ "\n"
  ++ "           := by" ++ "\n"
  ++ s!"  simp [findValidMonthDay_{a_1}]" ++ "\n"
  ++ "  simp [Icc, Subtype.ext_iff]" ++ "\n"
  ++ "  simp [monthLastDayAsDayOfYear] at hyd" ++ "\n"
  ++ "  have := incr_of_day_in_intervall dt ml h" ++ "\n"
  ++ "  split at hyd <;> simp_all" ++ "\n"
  ++ "  · simp [monthLastDayAsDayOfYear] at hne" ++ "\n"
  ++ "    rw [← heq] at hne" ++ "\n"
  ++ "    rw [← heq] at hyd" ++ "\n"
  ++ s!"    simp [dy'_month_{a_1}_eq dt true (by omega) hne hyd]" ++ "\n"
  ++ "    simp [monthLastDayAsDayOfYear]" ++ "\n"
  ++ s!"    have := dy'_month_{a_1}_day_eq dt true (by omega) hne hyd" ++ "\n"
  ++ "    simp_all" ++ "\n"
  ++ "  · simp [monthLastDayAsDayOfYear] at hne" ++ "\n"
  ++ "    rw [← heq] at hne" ++ "\n"
  ++ "    rw [← heq] at hyd" ++ "\n"
  ++ s!"    simp [dy'_month_{a_1}_eq dt false (by omega) hne hyd]" ++ "\n"
  ++ "    simp [monthLastDayAsDayOfYear]" ++ "\n"
  ++ s!"    have := dy'_month_{a_1}_day_eq dt false (by omega) hne hyd" ++ "\n"
  ++ "    simp_all" ++ "\n"

def gen_findValidMonthDay_month_eq' (a_1 : Nat) : String :=
  "/-- Generated by `gen_findValidMonthDay_month_eq'`. -/" ++ "\n"
  ++ s!"theorem findValidMonthDay_{a_1}_month_eq \{dt : Date} (isLeap : Bool) (yd : Time.Icc 1 366)" ++ "\n"
  ++ "  {ml : { m // monthLengthsOfDate m dt }}" ++ "\n"
  ++ "  (hml : ml = monthLengths_of_date dt) (h : dt.Day.val < ml.val.snd)" ++ "\n"
  ++ "  (heq : Time.dy' isLeap dt.Month dt.Day = yd.val) (hle : yd.val + 1 ≤ if isLeap then 366 else 365)" ++ "\n"
  ++ "  (hl : isLeapYear dt.Year = isLeap)" ++ "\n"
  ++ s!"  (hne : ¬yd.val + 1 ≤ (monthLastDayAsDayOfYear isLeap)[{a_1-2}].snd)" ++ "\n"
  ++ s!"  (hyd : yd.val+1 ≤ ((monthLastDayAsDayOfYear isLeap).get ⟨{a_1-1}, by simp⟩).2)" ++ "\n"
  ++ s!"    : (findValidMonthDay_{a_1} dt.Year isLeap ⟨yd + 1, incr_of_yd_in yd isLeap hle⟩ hl hne hyd).Month" ++ "\n"
  ++ "        = dt.Month" ++ "\n"
  ++ "      ∧ ⟨dt.Day.val + 1, incr_of_day_in_intervall dt ml h⟩" ++ "\n"
  ++ s!"        = (findValidMonthDay_{a_1} dt.Year isLeap ⟨yd.val + 1, incr_of_yd_in yd isLeap hle⟩ hl hne hyd).Day" ++ "\n"
  ++ "           := by" ++ "\n"
  ++ s!"  simp [findValidMonthDay_{a_1}]" ++ "\n"
  ++ "  simp [Icc, Subtype.ext_iff]" ++ "\n"
  ++ "  simp [monthLastDayAsDayOfYear] at hyd" ++ "\n"
  ++ "  have := incr_of_day_in_intervall dt ml h" ++ "\n"
  ++ "  split at hyd <;> simp_all" ++ "\n"
  ++ "  · simp [monthLastDayAsDayOfYear] at hne" ++ "\n"
  ++ "    rw [← heq] at hne" ++ "\n"
  ++ "    rw [← heq] at hyd" ++ "\n"
  ++ s!"    have := (month_{a_1-1}_if_lt true hml (by simp_all) hl)" ++ "\n"
  ++ s!"    simp [dy'_month_{a_1}_eq dt true (by omega) this hne hyd]" ++ "\n"
  ++ "    simp [monthLastDayAsDayOfYear]" ++ "\n"
  ++ s!"    have := dy'_month_{a_1}_day_eq dt true (by omega) this hne hyd" ++ "\n"
  ++ "    simp_all" ++ "\n"
  ++ "  · simp [monthLastDayAsDayOfYear] at hne" ++ "\n"
  ++ "    rw [← heq] at hne" ++ "\n"
  ++ "    rw [← heq] at hyd" ++ "\n"
  ++ s!"    have := (month_{a_1-1}_if_lt false hml (by simp_all) hl)" ++ "\n"
  ++ s!"    simp [dy'_month_{a_1}_eq dt false (by omega) this hne hyd]" ++ "\n"
  ++ "    simp [monthLastDayAsDayOfYear]" ++ "\n"
  ++ s!"    have := dy'_month_{a_1}_day_eq dt false (by omega) this hne hyd" ++ "\n"
  ++ "    simp_all" ++ "\n"

def genMontDayTheorems : IO Unit :=
  List.range' 3 8
  |> List.forM $ (fun i => do
    let m := (monthLastDayAsDayOfYear' true).get! i
    let p2 := (monthLastDayAsDayOfYear' false).get! (i-1)
    let pLen := p2.2.2-p2.2.1+1
    if pLen = 31 then
      IO.println (gen_findValidMonthDay_month_eq m.1)
    else
      IO.println (gen_findValidMonthDay_month_eq' m.1)
    )

--#eval genMontDayTheorems

def gen_monthLastDayAsDayOfYear'_month_eq_snd_le (a_1 a_2_1 a_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_monthLastDayAsDayOfYear'_month_eq_snd_le`. -/" ++ "\n"
  ++ s!"theorem monthLastDayAsDayOfYear'_month_{a_1}_eq_snd_le (dt : Date) (isleap : Bool)" ++ "\n"
  ++ "    (a : { x // x ∈ monthLastDayAsDayOfYear' isleap ∧ x.fst = dt.Month.val })" ++ "\n"
  ++ s!"  (h1 : (if isleap then {a_2_1} else {a_2_1'}) ≤ a.val.2.2)" ++ "\n"
  ++ s!"  (h2 : a.val.2.2 ≤ (if isleap then {n_2_1} else {n_2_1'}))" ++ "\n"
  ++ s!"    : a.val.1 = {a_1} := by" ++ "\n"
  ++ s!"  by_contra" ++ "\n"
  ++ s!"  have : ¬((if isleap then {a_2_1} else {a_2_1'}) ≤ a.val.snd.snd ∧ a.val.snd.snd ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"    have : ∀ a ∈ monthLastDayAsDayOfYear' isleap, ¬({a_1} = a.fst)" ++ "\n"
  ++ s!"     → ¬((if isleap then {a_2_1} else {a_2_1'}) ≤ a.2.2 ∧ a.2.2 ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"      cases isleap <;> simp [monthLastDayAsDayOfYear']" ++ "\n"
  ++ s!"    exact this a a.property.left (by omega)" ++ "\n"
  ++ s!"  have : (if isleap then {a_2_1} else {a_2_1'}) ≤ a.val.2.2 ∧ a.val.snd.snd ≤ (if isleap then {n_2_1} else {n_2_1'}) := by" ++ "\n"
  ++ s!"    cases isleap <;> simp_all" ++ "\n"
  ++ s!"  contradiction" ++ "\n"

def gen_monthLastDayAsDayOfYear'_month_eq_snd (a_1 a_2_1 a_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_monthLastDayAsDayOfYear'_month_eq_snd`. -/" ++ "\n"
  ++ s!"theorem monthLastDayAsDayOfYear'_month_{a_1}_eq_snd (dt : Date) (isleap : Bool)" ++ "\n"
  ++ "    (a : { x // x ∈ monthLastDayAsDayOfYear' isleap ∧ x.fst = dt.Month.val })" ++ "\n"
  ++ s!"  (h : a.val.1 = {a_1})" ++ "\n"
  ++ s!"  (h1 : (if isleap then {a_2_1} else {a_2_1'}) ≤ a.val.2.2)" ++ "\n"
  ++ s!"  (h2 : a.val.2.2 ≤ (if isleap then {n_2_1} else {n_2_1'}))" ++ "\n"
  ++ s!"    : a.val.2.2 = if isleap then {a_2_1} else {a_2_1'} := by" ++ "\n"
  ++ s!"  by_contra" ++ "\n"
  ++ s!"  have : ¬(a.val.1 = {a_1} ∧ (if isleap then {a_2_1} else {a_2_1'}) ≤ a.val.snd.snd" ++ "\n"
  ++ s!"           ∧ a.val.snd.snd ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"    have : ∀ a ∈ monthLastDayAsDayOfYear' isleap, ¬(a.2.2 = if isleap then {a_2_1} else {a_2_1'})" ++ "\n"
  ++ s!"      → ¬(a.1 = {a_1} ∧ (if isleap then {a_2_1} else {a_2_1'}) ≤ a.2.2 ∧ a.2.2 ≤ (if isleap then {n_2_1} else {n_2_1'})) := by" ++ "\n"
  ++ s!"      cases isleap <;> simp [monthLastDayAsDayOfYear']" ++ "\n"
  ++ s!"    exact this a a.property.left (by omega)" ++ "\n"
  ++ s!"  have : a.val.1 = {a_1} ∧ (if isleap then {a_2_1} else {a_2_1'}) ≤ a.val.2.2" ++ "\n"
  ++ s!"         ∧ a.val.snd.snd ≤ (if isleap then {n_2_1} else {n_2_1'}) := by" ++ "\n"
  ++ s!"    cases isleap <;> simp_all" ++ "\n"
  ++ s!"  contradiction" ++ "\n"

def gen_monthLastDayAsDayOfYearSndTheorems : IO Unit :=
  List.range' 1 10
  |> List.forM $ (fun i => do
    let m := (monthLastDayAsDayOfYear' true).get! i
    let m' := (monthLastDayAsDayOfYear' false).get! i
    let n1 := (monthLastDayAsDayOfYear' true).get! (i+1)
    let n2 := (monthLastDayAsDayOfYear' false).get! (i+1)
    IO.println (gen_monthLastDayAsDayOfYear'_month_eq_snd_le m.1 m.2.2 m'.2.2 (n1.2.2-1) (n2.2.2-1))
    IO.println (gen_monthLastDayAsDayOfYear'_month_eq_snd m.1 m.2.2 m'.2.2 (n1.2.2-1) (n2.2.2-1))
    )

--#eval gen_monthLastDayAsDayOfYearSndTheorems

def gen_findValidMonthDay_month_eq_incr (a_1 : Nat) : String :=
  "/-- Generated by `gen_findValidMonthDay_month_eq_incr`. -/" ++ "\n"
  ++ s!"theorem findValidMonthDay_{a_1}_month_eq_incr \{dt : Date} (isLeap : Bool) (yd : Time.Icc 1 366)" ++ "\n"
  ++ "  {ml : { m // monthLengthsOfDate m dt }}" ++ "\n"
  ++ s!"  (hml : ml = monthLengths_of_date dt) (h : dt.Day.val = ml.val.snd)" ++ "\n"
  ++ s!"  (hm : dt.Month.val < 12)" ++ "\n"
  ++ s!"  (heq : Time.dy' isLeap dt.Month dt.Day = yd.val)" ++ "\n"
  ++ s!"  (hl : isLeapYear dt.Year = isLeap)" ++ "\n"
  ++ s!"  (hn : ¬yd.val+1 ≤ ((monthLastDayAsDayOfYear isLeap).get ⟨{a_1-2}, by simp⟩).2)" ++ "\n"
  ++ s!"  (hyd : yd.val+1 ≤ ((monthLastDayAsDayOfYear isLeap).get ⟨{a_1-1}, by simp⟩).2)" ++ "\n"
  ++ s!"    : (findValidMonthDay_{a_1} dt.Year isLeap ⟨yd + 1," ++ "\n"
  ++ s!"          by have := dy'_lt_of_month_lt hm; cases isLeap <;> simp_all <;> omega⟩" ++ "\n"
  ++ s!"          hl hn hyd).Month = ⟨dt.Month.val + 1, by omega⟩" ++ "\n"
  ++ s!"      ∧ (findValidMonthDay_{a_1} dt.Year isLeap ⟨yd + 1," ++ "\n"
  ++ s!"          by have := dy'_lt_of_month_lt hm; cases isLeap <;> simp_all <;> omega⟩" ++ "\n"
  ++ s!"          hl hn hyd).Day = ⟨1, by omega⟩ := by" ++ "\n"
  ++ s!"  simp [findValidMonthDay_{a_1}]" ++ "\n"
  ++ s!"  simp [Icc, Subtype.ext_iff]" ++ "\n"
  ++ s!"  simp [monthLastDayAsDayOfYear] at hyd" ++ "\n"
  ++ s!"  split at hyd" ++ "\n"
  ++ s!"  · simp [] at hyd" ++ "\n"
  ++ s!"    simp [monthLastDayAsDayOfYear] at hn" ++ "\n"
  ++ s!"    split at hn" ++ "\n"
  ++ s!"    · simp [] at hn" ++ "\n"
  ++ s!"      simp [monthLastDayAsDayOfYear]" ++ "\n"
  ++ s!"      split <;> simp_all" ++ "\n"
  ++ s!"      rw [← hml] at h" ++ "\n"
  ++ s!"      simp_all [findValidMonthDay_{a_1}_month_eq_incr' true yd hml h heq hl (by simp_all; omega) (by simp_all)]" ++ "\n"
  ++ s!"    · contradiction" ++ "\n"
  ++ s!"  · simp [] at hyd" ++ "\n"
  ++ s!"    simp [monthLastDayAsDayOfYear] at hn" ++ "\n"
  ++ s!"    split at hn" ++ "\n"
  ++ s!"    · contradiction" ++ "\n"
  ++ s!"    · simp [] at hn" ++ "\n"
  ++ s!"      simp [monthLastDayAsDayOfYear]" ++ "\n"
  ++ s!"      split <;> simp_all" ++ "\n"
  ++ s!"      rw [← hml] at h" ++ "\n"
  ++ s!"      simp_all [findValidMonthDay_{a_1}_month_eq_incr' false yd hml h heq hl (by simp_all; omega) (by simp_all)]" ++ "\n"

def gen_findValidMonthDay_month_eq_incr' (a_1 a_2_1 a_2_1' n_2_1 n_2_1' : Nat) : String :=
  "/-- Generated by `gen_findValidMonthDay_month_eq_incr'`. -/" ++ "\n"
  ++ s!"theorem findValidMonthDay_{a_1}_month_eq_incr' \{dt : Date} (isLeap : Bool) (yd : Time.Icc 1 366)" ++ "\n"
  ++ "  {ml : { m // monthLengthsOfDate m dt }}" ++ "\n"
  ++ s!"  (hml : ml = monthLengths_of_date dt) (h : dt.Day.val = ml.val.snd)" ++ "\n"
  ++ s!"  (heq : Time.dy' isLeap dt.Month dt.Day = yd.val) (hl : isLeapYear dt.Year = isLeap)" ++ "\n"
  ++ s!"  (h1 : (if isLeap then {a_2_1} else {a_2_1'}) ≤ yd.val)" ++ "\n"
  ++ s!"  (h2 : yd.val ≤ if isLeap then {n_2_1} else {n_2_1'})" ++ "\n"
  ++ s!"    : dt.Month.val = {a_1-1} ∧ yd.val = (if isLeap then {a_2_1} else {a_2_1'}) := by" ++ "\n"
  ++ s!"  simp [dy'] at heq" ++ "\n"
  ++ s!"  let a := memOfMonth isLeap dt.Month" ++ "\n"
  ++ s!"  have : a = memOfMonth isLeap dt.Month := by simp" ++ "\n"
  ++ s!"  rw [← this] at heq" ++ "\n"
  ++ s!"  have := yd_eq_monthLastDayAsDayOfYear'_val isLeap yd hml h ml.property heq hl" ++ "\n"
  ++ s!"  rw  [← this] at h1" ++ "\n"
  ++ s!"  rw  [← this] at h2" ++ "\n"
  ++ s!"  rw [← a.property.right]" ++ "\n"
  ++ s!"  have := monthLastDayAsDayOfYear'_month_{a_1-1}_eq_snd_le dt isLeap a h1 h2" ++ "\n"
  ++ s!"  have := monthLastDayAsDayOfYear'_month_{a_1-1}_eq_snd dt isLeap a this h1 h2" ++ "\n"
  ++ s!"  simp_all" ++ "\n"

def gen_monthDayEqIncrTheorems : IO Unit :=
  List.range' 3 8
  |> List.forM $ (fun i => do
    let m := (monthLastDayAsDayOfYear' true).get! i
    let m' := (monthLastDayAsDayOfYear' false).get! i
    let p1 := (monthLastDayAsDayOfYear' true).get! (i-1)
    let p2 := (monthLastDayAsDayOfYear' false).get! (i-1)
    IO.println (gen_findValidMonthDay_month_eq_incr' m.1 p1.2.2 p2.2.2 (m.2.2-1) (m'.2.2-1))
    IO.println (gen_findValidMonthDay_month_eq_incr m.1)
    )

--#eval gen_monthDayEqIncrTheorems
